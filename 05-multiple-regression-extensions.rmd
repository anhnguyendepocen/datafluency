---
title: 'Multiple regression'
author: 'Ben Whalley'
date: "September 2020"
bibliography: [references.bib]
biblio-style: apa6
link-citations: yes
output:
  webex::html_clean:
    includes:
      after_body: footer.html
---



```{r include=F,echo=F}
library(tidyverse)
library(webex)
library(cowplot)
library(DiagrammeR)
library(pander)
library(broom)
source('grvizpng.R')
theme_set(theme_minimal())
knitr::opts_chunk$set(cache=T, message=F, warning=F)

studyhabits <- read_csv('https://benwhalley.github.io/rmip/data/studyhabitsandgrades.csv')
```




NOTE: if you are not sure why the following exercises are useful or relevant to the multiple regression session then bear with me to the end; it will become clearer!



# Sequences and designs for sampling and allocation

One trick you may find useful later in the course is making **sequences** of numbers.

There are a few ways to do this, but the simplest is to write: `1:10`. That is, the number to start
from (`1`), a colon (`:`), and then the number to end with (`10`).

Copy and paste these examples to see the output:

```{r}
1:10
20:30
```

**Explanation**: The output shows that R has created a sequence of whole numbers between the start
and finish number.

To get a sequence with only even numbers, we can use the `seq` function, and set the `by` argument
to 2:

```{r}
seq(from=2, to=10, by=2)
```

You can set `by` to any number, including a decimal:

```{r}
seq(0, 27, by=3)
seq(0, 1, by=0.2)
```

If your sequence doesn't have a simple pattern, you can also write out the numbers by hand using the
`c()` function E.g.:

```{r}
c(1,40,92,188)
```

**Explanation**: `c(...)` is short for `combine`, so this command combines the numbers 1, 40, 92,
188 into a new sequence. This is sometimes called a **vector** in R-speak.

:::{.exercise}

Make some sequences which include:

-   Even numbers from 10 to 20
-   Numbers in the 8 times table less than 200
-   20 evenly spaced numbers between zero and 1 (including zero and 1)
-   The words "Wibble", "Wobble" and "Bobble"

`r hide("Show answers")`

We can use `seq` for numbers:

```{r}
seq(10,20,by=2)
seq(0,200, 8)
seq(0,1, by=1/19)
```

But we need to use c() for lists of words:

```{r}
c("Wibble", "Wobble", "Bobble")
```

`r unhide()`

:::

# Combinations of sequences {#expand-grid}

In designing experiments, or creating a grid of numbers for making predictions, we often want to create combinations of different categories which represent conditions or stimuli.

Imagine a hypothetical study with a test phase where participants are presented with multiple words,
in either red or green text, and shown at either the bottom or top of the computer screen.

The combinations look something like this:

```{r echo=F}
expand.grid(
   colour=c("Red", "Green"),
   position=c("Top", "Bottom"),
   word = c("Nobble", "Wobble", "Hobble")) %>%
   as_tibble() %>%
mutate(condition = row_number())%>% select(condition, everything())%>%
pander()
```

R provides quick ways of creating combinations of variables, using a command called `expand.grid`.

First, we need to create a sequence of each of the possible values for our categories:

```{r}
colours = c("Red", "Green")
positions = c("Top", "Bottom")
words = c("Nobble", "Wobble", "Hobble")
```

Then we can use `expand.grid` to give us all the possible combinations of these:

```{r}
expand.grid(colour=colours, position=positions, words = words)
```

**Explanation**: The `expand.grid` function has taken the items in the three input sequences
(colours, positions and words) and created a dataframe which contains all the possible combinations. We could save these to a file if we wanted to use them as part of our experiment.


:::  {.exercise}

Create some experimental designs of your own

1. Reproduce the experiment design above by copying and pasting

2. Adapt the commands to allow for an experiment where the word position could be either top,
   bottom, left or right. How many different conditions would there be in this case?

As a stretch task (this might be sligtly harder):

1. How would you create a design where the order of presentation of each word is also balanced? That
   is, where it's equally likely to see Nobble, Wobble or Bobble in the first, second or third
   trial?

   
:::   
   


:::{.exercise}



Take the model from the main worksheet were we predicted grades from work hours for men and women.

In the main worksheet we created a dataframe by hand to tell `augment` what predictions we wanted.

Now try using `expand.grid` to make the new dataframe instead. 
For example, try making predictions for men and women who work 20, 25, 30, 35, or 40 hours per week. Make this dataframe using `expand.grid` and without using the `c()` function.
   
:::
   
   

# Clinical trial example


:::{.exercise}

Data from a clinical trial of Functional Imagery Training [@solbrig2019functional, FIT] are
available at <https://zenodo.org/record/1120364/files/blind_data.csv>. In this file, `group`
represents the treatment group (FIT=2; Motivational Interviewing=1). The `kg1` and `kg3` variables
represent the patients' weights in kilograms before and after treatment, respectively. Load these
data and complete the following tasks:

1. Plot the difference in weight between treatment groups at followup (`kg3`)

2. Create a plot to show whether men or women benefited most from the treatment (this will require
   some thinking about what goes on the y-axis, and perhaps some pre-processing of the data).

3. Create a plot to show whether older participants benefited more or less than younger ones (again
   this will require some thinking, and there are quite a number of different plot types which could
   be used, each with different pros and cons).
   
4. Run a linear model which is equivalent to the plot you created. Can you match the coefficients in the model output to the points and lines on your graph?

:::





```{r}
list.files()

combined <- tibble(subject=list.files("data", "*.csv", full.names=T)) %>%
  rowwise() %>% 
  do(read_csv(.$subject) )
  
```

